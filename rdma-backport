#!/usr/bin/ruby

require 'optparse'

VALID_REPO = "github"
STABLE_REPO = "stable"

def checkLog(br1, br2, action_msg)
    puts "Diff between #{br1} and #{br2}"
    puts `git shortlog #{br1} ^#{br2}`
    rep = 't'
    while rep != "y" && rep != "n" && rep != '' do
        puts "Do you wish to #{action_msg} this branch ? (y/N): "
        rep = STDIN.gets.chomp()
    end
    return rep
end

opts = {
    :base_ver => 0,
    :commits => [],
    :do_push => false,
    :do_merge => false,
    :br_suff => "master",
    :submit_stable => false
}

optsParser = OptionParser.new(nil, 60)
optsParser.banner = "Usage: #{__FILE__}  [-v <min_version>] [-c <SHA1> [-c <SHA1> [...]]]"
optsParser.separator ""
optsParser.separator "Options:"
optsParser.on("-h", "--help", "Display usage.") { |val| puts optsParser.to_s; exit 0 }
optsParser.on("-v", "--base-version <[0-9]*>", Integer, "Older release to consider.") {
    |val| opts[:base_ver] = val}
optsParser.on("-c", "--sha1 <sha1>", String, "Commit to cherry-pick. Can be used multiple time.") {
    |val| opts[:commits] << val}
optsParser.on("-p", "--[no-]push", "Push branches to github for Travis review.") {
    |val| opts[:do_push] = val}
optsParser.on("-b", "--branch-suffix <suffix>", "Branch suffix. Default is 'master'.") {
    |val| opts[:br_suff] = val}
optsParser.on("-m", "--merge <suffix>", "Merge branch with suffix.") {
    |val| opts[:do_merge] = val}
optsParser.on("--submit-stable", "Submit to stable repo.") {
    |val| opts[:submit_stable] = true}

rest = optsParser.parse!(ARGV);
raise("Extra Unexpected extra arguments provided: " + rest.map(){|x|"'" + x + "'"}.join(", ")) if rest.length != 0

if opts[:do_merge] != false then
    if opts[:commits].length != 0 then
        raise "Cannot merge and cherry pick commits at the same time"
    end
    if opts[:submit_stable] != false
        raise "Cannot merge and submit to stable at the same time"
    end
end
if opts[:submit_stable] == true then
    if opts[:br_suff] != "master" then
        raise "Only master suffixed branches can be pushed to the stable repo"
    end
    `git fetch stable`
end

STABLE_LIST=`git branch`.split("\n").map(){|x|
    x=~ /dev\/stable-v[0-9][0-9]\/#{opts[:br_suff]}/ ?
        x.gsub(/\*?\s*dev\/stable-v([0-9][0-9])\/#{opts[:br_suff]}\s*$/, '\1') :
        nil}.compact()

STABLE_LIST.each(){|stable|
    if stable.to_i < opts[:base_ver] then
        puts "Skipping older v#{stable}"
        next
    end
    local_branch = "dev/stable-v#{stable}/#{opts[:br_suff]}"

    puts "Backporting for v#{stable}"
    puts `git checkout #{local_branch}`
    if $? != 0 then
        raise "Error: Failed to checkout the branch"
        exit 1
    end

    if opts[:commits].length > 0 then
        `git cherry-pick #{opts[:commits].join(" ")}`
        if $? != 0 then
            puts "Cherry pick failure. Starting bash for manual fixes. Exit shell to continue"
			`bash`
            puts "Continuing..."
		end
    end
    if opts[:do_merge] != false then
        merge_branch = "dev/stable-v#{stable}/#{opts[:do_merge]}"
        rep = checkLog(local_branch, merge_branch, "merge")
        if rep == "y" then
            puts `git merge dev/stable-v#{stable}/#{opts[:do_merge]}`
            if $? != 0 then
                puts "Merge failure. Starting bash for manual fixes. Exit shell to continue"
			    `bash`
                puts "Continuing..."
		    end
        else
            puts "Skipping merge"
        end
    end
    if opts[:do_push] == true then
        puts `git push github #{local_branch}`
    end

    if opts[:submit_stable] == true then
        remote_branch="stable-v#{stable}"
        remote_ref = "#{STABLE_REPO}/#{remote_branch}"
        rep = checkLog(local_branch, remote_ref, "submit")
        if rep == "y" then
            puts `git push stable #{local_branch}:#{remote_branch}`
        else
            puts "Skipping submission"
        end

    end
}
